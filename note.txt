javac include external jar:
Window: javac -cp path\to\jar path\to\sourcefile
Example: javac -cp .\lib\*.jar .\src\HelloWorld.java

Linux: javac -cp path/to/jar path/to/sourcefile
Example: javac -cp ./lib/*.jar ./src/HelloWorld.java

Export classpath:
export CLASSPATH=.:$CLASSPATH:/floder/to/jar

javac with multiple jar:
javac -cp lib/\* ./src/HelloWorld.java

http://superuser.com/questions/603026/mysql-how-to-fix-access-denied-for-user-rootlocalhost
mysql how to fix Access denied for user 'root'@'localhost'
Follow the steps below.

Start the MySQL server instance or daemon with the --skip-grant-tables option (security setting).

$ mysqld --skip-grant-tables
Execute these statements.

$ mysql -u root mysql
$mysql> UPDATE user SET Password=PASSWORD('my_password') where USER='root';
$mysql> FLUSH PRIVILEGES;
Finally, restart the instance/daemon without the --skip-grant-tables option.

$ /etc/init.d/mysql restart
You should now be able to connect with your new password.

$ mysql -u root -p
Enter password: my_password


What is a race condition?
A race condition occurs when two or more threads can access shared data and they try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, you don't know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data.

Problems often occur when one thread does a "check-then-act" (e.g. "check" if the value is X, then "act" to do something that depends on the value being X) and another thread does something to the value in between the "check" and the "act". E.g:

if (x == 5) // The "Check"
{
   y = x * 2; // The "Act"

   // If another thread changed x in between "if (x == 5)" and "y = x * 2" above,
   // y will not be equal to 10.
}
The point being, y could be 10, or it could be anything, depending on whether another thread changed x in between the check and act. You have no real way of knowing.

In order to prevent race conditions from occurring, you would typically put a lock around the shared data to ensure only one thread can access the data at a time. This would mean something like this:

// Obtain lock for x
if (x == 5)
{
   y = x * 2; // Now, nothing can change x until the lock is released. 
              // Therefore y = 10
}
// release lock for x


wait
public final void wait()
                throws InterruptedException
Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0).
The current thread must own this object's monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.

As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:

     synchronized (obj) {
         while (<condition does not hold>)
             obj.wait();
         ... // Perform action appropriate to condition
     }
 
This method should only be called by a thread that is the owner of this object's monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.
Throws:
IllegalMonitorStateException - if the current thread is not the owner of the object's monitor.
InterruptedException - if any thread interrupted the current thread before or while the current thread was waiting for a notification. The interrupted status of the current thread is cleared when this exception is thrown.
See Also:
notify(), notifyAll()


notify
public final void notify()
Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object's monitor by calling one of the wait methods.
The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object. The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.

This method should only be called by a thread that is the owner of this object's monitor. A thread becomes the owner of the object's monitor in one of three ways:

By executing a synchronized instance method of that object.
By executing the body of a synchronized statement that synchronizes on the object.
For objects of type Class, by executing a synchronized static method of that class.
Only one thread at a time can own an object's monitor.

Throws:
IllegalMonitorStateException - if the current thread is not the owner of this object's monitor.
See Also:
notifyAll(), wait()


Starvation and Livelock

Starvation and livelock are much less common a problem than deadlock, but are still problems that every designer of concurrent software is likely to encounter.

Starvation

Starvation describes a situation where a thread is unable to gain regular access to shared resources and is unable to make progress. This happens when shared resources are made unavailable for long periods by "greedy" threads. For example, suppose an object provides a synchronized method that often takes a long time to return. If one thread invokes this method frequently, other threads that also need frequent synchronized access to the same object will often be blocked.

Livelock

A thread often acts in response to the action of another thread. If the other thread's action is also a response to the action of another thread, then livelock may result. As with deadlock, livelocked threads are unable to make further progress. However, the threads are not blocked â€” they are simply too busy responding to each other to resume work. This is comparable to two people attempting to pass each other in a corridor: Alphonse moves to his left to let Gaston pass, while Gaston moves to his right to let Alphonse pass. Seeing that they are still blocking each other, Alphone moves to his right, while Gaston moves to his left. They're still blocking each other, so...

vim command:
set line number: :set number
set auto indent: :set autoindent
set auto complete: in insert model, ctrl + p/ctrl + n get a list of suggestions.name


java multi-thread dead lock:
jps -l -m
jstack pid

change file permission:
sudo chmod xxx filename

remove software from linux:
list all installed software: dpkg --list
remove software: sudo apt-get remove softwarename

~/.ssh/config
Host name
	HostName ************
	User ubuntu
	IdentityFile /path/to/pem

head -n number file
print the first numberth line of file
tail -n number file
print the last numberth line of file

generate ssh-public-key: ssh-keygen -t rsa

vim multiple window switch:
ctrl + w

tar directory:
    tar -zcvf compressFileName.tar.gz folderToCompress

change computer name:
    sudo vim /etc/hostname
    sudo vim /etc/hosts

python function parameter passing:
    the parameter passed in as a reference, but the reference is passed by value.

/usr/bin/env bad interpreter: no such file or directory:
    reinstall env file:
        sudo apt-get install --reinstall coreutils

show current path:
    pwd

change password:
    passwd

list file in detail mode:
    ls -l

who am i:
    whoami

list login user:
    users
    who
    w

system shutdown:
    halt, brings the system down immediately
    poweroff, shut down by powering off
    reboot, reboot
    shutdown, shutdown

meta characters:
    * any number of characters
    ? one character

create parent directory:
    mkdir -p

remove directory:
    rmdir name

environment variable:
    set without $
    access with $

environment variable RANDOM:
    generate a random integer between 0 and 32,767

send and receive email:
    mail

sort option:
    -n, sort numerically, ignore blanks and tabs
    -r, reverse the order of sort
    -f, sort upper- and lowercase together
    +x, ignore first x fields when sorting

list running process:
    ps, list user's process
    -f, more information about running process

vi string replace:
    :%s/original text/new text/g(globally)

scp folder option: -r

shell read only variable:
    readonly label before variable name, e.g.: readonly name

shell unset variable:
    unset variable_name
    this will tell the shell to remove the variable from the list of variables it tracks. Once you unset a variable, you cannot be able to access the value stored in the variable.

special variables:
    $$:the pid of current shell
    $0: the filename of the current script
    $n: the arguments with which a script is invoked
    $#: the number of arguments supplied to a script
    $?: the exit status of the previous command

bash array:
    initializtion: array_name=(value1 ... valuen)
    access array value: ${array_name[index]}
    access all values: ${array_name[*]} or ${array_name[@]}

expression:
    val = 'expr 2 + 2': space between operator and opertan, ''
    all the conditional expressions are put inside square braces with one spaces around them.

relational operator:
    specific to numberic values. not work for string values unless their value is numberic
    -eq
    -ne
    -gt
    -lt
    -ge
    -le
    all conditional expressions are put inside square braces with one spaces around them

Boolean operator:
    ! logical negation
    -o logical OR
    -a logical AND
    all logical expressions are put inside square braces with one space aroud them

String operator:
    = equal or not
    != equal or not
    -z if string size is zero
    -n if string size is non-zero
    str if str is not empty
    all expressions are put inside square braces with one space around them

File test operator:
    -b file if file is a block special file
    -c file if file is a character special file
    -d file if file is a directory
    -f file if file is an ordinary file
    -g file if file has its set group id
    -r file if file is readable
    -w file if file is writable
    -x file if file is executable
    -s file if file has size greater than 0
    -e file if file exists
    all expressions are put inside square braces with one space around them

Decision making:
    if:
        if [ expression1 ]
        then
            statements
        elif
        then
            statements
        elif
        then
            statements
        else
            statements
        fi

    case...esac:
        case word in
            pattern1)
                statements
                ;;
            pattern2)
                statements
                ;;
            pattern3)
                statements
                ;;
        esac

Loop:
    while loop:
        while command
        do
            statements
        done

    for loop:
        for var in word1 word2 ... wordn
        do
            statements
        done
    
    until loop:
        until command
        do
            statements
        done

    select loop:
        select var in word1 word2 ... wordn
        do
            statement
        done

echo -e option:
    enable interpretation of backslash escapes

command substitution:
    the shell performs a given set of commands and the substitutes their output in place of the output of the commands.
    syntax: `command`, here is backquote, not the single quote character
