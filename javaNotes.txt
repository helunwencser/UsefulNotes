java is compile language, java source code is compile to bytecode by compile and interpreted by jvm at running time to machine code. So it can be both compiled and interpreted language. But here the iterpretation is different from intrepreting high-level language to machine code directly.

fragile base class problem: when an api's signature has changed to a new version, the jvm will check the new version and try to load the new version when running but not crash the program.It works with very late binding and dynamic loading with programmable class loaders.

Late binding: offset are not calculated until load time, field and method references represented symbolically in the bytecode.

Java environment:
	Java2SE: JRE, JDK
	Java2EE: Servlet Development Kit, EJB implementation

char 16 bit unicode not 8 bit

default values: 0 for basic types, null for others

string: str = "val" is stored in method area;
	str = new String("val"); is stored in the heap

add no arg constructor to initialize all properties.

private: useable in class
protected: usable in package or with inheritance
public: useable everywhere

printf available in System.out.printf with same format as in C.

composition - strong association
	    - weak associtation: passing an object by reference in a method

Object relationship:
	Encapsulation - making data in a class private
	Containment 
	Association
	Inheritance
	Polymorphism

Encapsulation:
	class level encapsulation
	component level encapsulation

package:
	floders created for grouping common classes
	protected - package level variables(accessible or usable in any class
within a package)

Exception Handling:
	Error: cannot recover from, program will crash.
	Exception: can recover
		know about the exceptions and can do something about it(checked)
			are subclasses of RuntimeException
			try/catch clause must be used
		new problems and do not know what to do(unchecked)
			are subclasses of Exception

Customer Exception:
	associated error number and error message is required

JNI:
	java native interface

Object Relationships:
	Encapsulation: private data members
	Association: passing an object by reference
	Containment: instantiating an object inside another class
	Inheritance: recycling the properties and methods from parent to child
	Polymorphism: single method

Inner class:
	Inner class is not recommended.
	Other classes can access inner class if it is defined as public.
	Inner class can access all properties of outer class directly. But
outer class cannot access properties of inner class directly even if it is
public. Outer class can only access properties of inner class throug an
instance of inner class even if properties are private.
	Type 1:
		An instance of outer class has to be created for creating an
instance of inner. Inner class code acts like an instance for code access
perspective. e.g.: Outer outer = new Outer(); Inner inncer = outer.new
Inner();
	Type 2:
		Local inner class(side a method). Can only be abstract or
final, on other modifiers are allowed. No static variables are allowed.
	Type 3: Using an class with word static in front of it.
